# 内存4区

## 程序运行前

在程序运行前，分为**代码区**和**全局区**

### 1.代码区

存放机器指令

特点

- 共享。内存中只有1份代码
- 只读。避免程序运行过程中意外地修改了指令



### 2.全局区

存放**全局变量（静态或动态）、静态局部变量、全局常量（用const修饰）、字符串常量**

注意：**动态局部变量、局部常量（用const修饰）**不是存放在全局区

特点：

- 程序结束后，由**操作系统**释放



例如以下代码：

```c++
#include<iostream>
using namespace std;

//动态全局变量
int g_a=10;
int g_b=11;

//静态全局变量
static int s_g_a=10;
static int s_g_b=11;

//全局常量
const int c_g_a=10;
const int c_g_b=11;

int main()
{
    cout<<"动态全局变量a的地址:"<<&g_a<<endl;
    cout<<"动态全局变量b的地址:"<<&g_b<<endl;

    cout<<"静态全局变量a的地址:"<<&s_g_a<<endl;
    cout<<"静态全局变量b的地址:"<<&s_g_b<<endl;

    cout<<"全局常量a的地址:"<<&c_g_a<<endl;
    cout<<"全局常量b的地址:"<<&c_g_b<<endl;

    //动态局部变量
    int a=1;
    int b=2;
    cout<<"动态局部变量a的地址:"<<&a<<endl;
    cout<<"动态局部变量b的地址:"<<&b<<endl;

    //静态局部变量
    static int s_a=1;
    static int s_b=2;
    cout<<"静态局部变量a的地址:"<<&s_a<<endl;
    cout<<"静态局部变量b的地址:"<<&s_b<<endl;

    //局部常量
    const int c_a=10;
    const int c_b=11;
    cout<<"局部常量a的地址:"<<&c_a<<endl;
    cout<<"局部常量b的地址:"<<&c_b<<endl;

    //字符串常量
    cout<<"字符串常量的地址:"<<&"Hello world"<<endl;

    return 0;
}
```



运行结果如下：

```cmd
动态全局变量a的地址:0x403010
动态全局变量b的地址:0x403014

静态全局变量a的地址:0x403018
静态全局变量b的地址:0x40301c

全局常量a的地址:0x404004
全局常量b的地址:0x404008

动态局部变量a的地址:0x62fe4c
动态局部变量b的地址:0x62fe48

静态局部变量a的地址:0x403020
静态局部变量b的地址:0x403024

局部常量a的地址:0x62fe44
局部常量b的地址:0x62fe40

字符串常量的地址:0x40410a
```



## 程序运行后

### 3.栈区

存放**动态局部变量、函数形参**

特点：

- 由**编译器**自动分配、释放
- 栈区中的数据 在函数或块执行完后，自动释放。所以函数**不能**返回局部变量的地址，但是**可以返回局部变量的值**。

```c++
int func1()
{
    int x=10;
    return x;//返回局部变量的值
}

int *func2()
{
    int y=100;
    return &y;//返回局部变量的地址
}

int main()
{
	//正确
    int x=func1();
    cout<<x<<endl;
    cout<<x<<endl;
	
	//会报错
    int *p=func2();
    cout<<*p<<endl;
    cout<<*p<<endl;

    return 0;
}
```



### 4.堆区

特点：

- 由**程序员**分配和释放。若程序员不释放，则在程序结束时由**操作系统**释放。
- C++中，利用`new`在堆区分配内存，利用`delete`释放堆区的内存



## 每个区域存放的数据总览

1. 全局数据区
   - 全局变量，静态数据和常量  
   - **类的静态成员变量**  
2. 代码区
   - 所有类成员函数和非成员函数代码  
3. 栈区
   - 局部变量、函数参数、返回数据、返回地址  
4. 堆区
   - 程序员自己分配

特别地：

1. **非静态成员变量**在类的实例内，实例在栈区或者堆区。
2. **虚函数指针、虚基类指针**在类的实例内，实例在栈区或者堆区
3. **类的实例**
   - 如果是定义的类变量，则在栈内存区，
   - 如果是new出来的类指针，则在**堆**内存区，同时**引用**会保存在**栈**区。
