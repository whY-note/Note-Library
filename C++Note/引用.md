# 引用

## 作用

给变量起别名



## 语法



>**数据类型 *&* 别名=原名**
>
>
>
>例如：
>
>`int &ra=a`
>
>`double &rb=b`

示例：

```c++
#include<iostream>
using namespace std;

int main()
{
    int a=10;
    int &ra=a;

    cout<<"a="<<a<<endl;
    cout<<"ra="<<ra<<endl;

    //通过别名来改变变量的值
    ra=100;
    cout<<"通过别名来改变变量的值 之后"<<endl;
    cout<<"a="<<a<<endl;
    cout<<"ra="<<ra<<endl;
    return 0;
}
```

运行结果：

```cmd
a=10
ra=10
通过别名来改变变量的值 之后
a=100
ra=100
```



由此可见，

ra和a都是同一个变量的变量名，通过ra或a**都可以改变这个变量的值**



## 注意事项

1.引用一定要**初始化**

>**正确**示例
>
>```c++
>int a=10;
>int &b=a;//b初始化为a
>```
>
>
>
>**错误**示例
>
>```c++
>int &b;//没有初始化
>
>int &c=10;//引用的初始化，应该是某个变量，而不是常量
>```



2.引用初始化后，就**不能更换**其引用的变量，只能对其引用的变量**赋值**

示例：

```c++
//别名初始化后，不能更换其引用的变量，只能对其引用的变量赋值
int b=1;
ra=b;//则是赋值操作，把b的值赋给ra

cout<<"执行 ra=b; 之后"<<endl;
cout<<"ra="<<ra<<endl;
cout<<"a="<<a<<endl;
cout<<"b="<<b<<endl;

cout<<"ra的地址="<<&ra<<endl;
cout<<"a的地址="<<&a<<endl;
cout<<"b的地址="<<&b<<endl;
```

运行结果：

```cmd
执行 ra=b; 之后
ra=1
a=1
b=1
ra的地址=0x62fe44
a的地址=0x62fe44
b的地址=0x62fe40
```

由此可见，

`ra=b;`**不能**把ra所引用的变量**更换为b**，只能对ra引用的变量**赋b的值**



## 引用作函数形参

变量的引用作函数形参，**形参会修饰实参，**

即：形参改变后，实参也会跟着改变

效果与地址传递相同！



示例：

```c++
#include<iostream>

using namespace std;

void swap1(int a,int b)//值传递，形参不会修饰实参
{
    int temp=a;
    a=b;
    b=temp;
    cout<<"形参:a="<<a<<" b="<<b<<endl;
}

void swap2(int *a,int *b)//址传递，形参会修饰实参
{
    int temp=*a;
    *a=*b;
    *b=temp;
    cout<<"形参:a="<<*a<<" b="<<*b<<endl;
}

void swap3(int &a,int &b)//引用传递，形参会修饰实参
{
    int temp=a;
    a=b;
    b=temp;
    cout<<"形参:a="<<a<<" b="<<b<<endl;
}

int main()
{
    int a=1,b=2;

    swap1(a,b);
    cout<<"实参:a="<<a<<" b="<<b<<endl;

    swap2(&a,&b);
    cout<<"实参:a="<<a<<" b="<<b<<endl;

    swap3(a,b);
    cout<<"实参:a="<<a<<" b="<<b<<endl;
    return 0;
}
```

运行结果：

```cmd
//swap1,值传递，形参不会修饰实参
形参:a=2 b=1
实参:a=1 b=2

//swap2,址传递，形参会修饰实参
形参:a=2 b=1
实参:a=2 b=1

//swap3,引用传递，形参会修饰实参
形参:a=1 b=2
实参:a=1 b=2
```



## 引用作函数返回值

### 1.不能返回局部变量的引用

>因为局部变量（默认是动态局部变量）放在栈区，在函数调用结束后会自动释放。
>
>所以，返回**局部变量的引用**与返回**局部变量本身**一样，第一次是正常的值（因为编译器做了保留），第二次就乱码



正确做法：返回静态局部变量的引用

>因为静态局部变量存放在全局区，在函数调用结束后不会自动释放，在整个文件运行完后才由系统释放。
>
>所以，返回**静态局部变量的引用**不会乱码

```c++
int& func()
{
    static int a=10;//静态局部变量，存放在全局区
    return a;
}

int  main()
{
    int& ref=func();
    cout<<"ref="<<ref<<endl;
    cout<<"ref="<<ref<<endl;
    return 0;
}
```

运行结果：

```cmd
ref=10
ref=10
```



### 2.函数调用可以作为左值

**返回值为引用**的函数，可以作为左值

示例

```c++
int& func()
{
    static int a=10;//静态局部变量，存放在全局区
    cout<<"a="<<a<<endl;
    return a;
}

int  main()
{
    int& ref=func();
    cout<<"ref="<<ref<<endl;
    cout<<"ref="<<ref<<endl;

    func()=1000;//函数调用作为左值
    cout<<"ref="<<ref<<endl;
    cout<<"ref="<<ref<<endl;

    func();//再次调用函数，目的是打印出a的值
    return 0;
}
```



运行结果：

```cmd
a=10
ref=10
ref=10
a=10
ref=1000
ref=1000
a=1000//由此可见，a的值与ref相同，说明变量a的值通过'func()=1000;'进行了修改
```



由此可见，

**返回值为引用**的函数，可以作为左值。 例如示例中的 `func()=1000;`

这时，**表面上**是函数调用作为左值，

而**本质上**的是，**函数返回的引用**作为左值，

所以，对函数调用进行赋值（示例是中对 `func()` 赋值），其实是对函数返回的引用进行赋值（示例中是对`a`赋值）



## 引用的本质

引用的本质是**指针常量**

### 1.给变量起别名 的本质

```c++
int a=10;

//给变量起别名
int &ref=a; //本质上是：int* const ref=a
```

**编译器**会自动帮我们完成这个转换



### 2.通过别名来改变变量的值 的本质

```c++
//通过别名来改变变量的值
ref=100;    //本质上是：*ref=100
```

**编译器**会自动帮我们完成这个转换



### 3.总结！

> [!IMPORTANT]
>
> 引用的本质是**指针常量**（`int* const`），
>
> 正因此，不能更换引用的变量
>
> 因为**指针常量**（`int* const`）不能改变所指向的变量





## 常量引用

### 语法

```c++
const int& ref=10;
```

> [!CAUTION]
>
> Why `int& ref=10`报错，但是`const int& ref=10;`不报错？
>
> 解释：
>
> 实际上编译器把`const int& ref=10;`变成了2句代码：
>
> ```c++
> int temp=10;
> const int& ref=temp;
> ```



### 常量引用的本质

根据引用的本质，容易推知常量引用的本质：

|      | 引用                                                  | 常量引用                                                     |
| ---- | :---------------------------------------------------- | ------------------------------------------------------------ |
| 表面 | `int& ref=a`                                          | `const int& ref=a`                                           |
| 本质 | `int* const ref=a` 指针常量，指针所指向的对象不能改变 | `const int* const ref=a` 指针所指向的对象不能改变，而且 指针所指向的对象的值也不能改变（`ref=10`,错！） |



### 应用场景

用于修饰函数形参，**防止对函数形参进行*误操作***

```c++
void myPrint(const int& a)
{
    //a=10;//会报错，因为a是常量引用，不可修改
    cout<<"a="<<a<<endl;
}

int main()
{
    int a=1;
    myPrint(a);
    return 0;
}
```

运行结果：

```cmd
a=1
```

